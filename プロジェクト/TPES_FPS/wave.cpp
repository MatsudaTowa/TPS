//=============================================
//
//ウェーブ処理[wave.h]
//Auther Matsuda Towa
//
//=============================================
#include "wave.h"
#include "enemy_test.h"
#include "manager.h"
const std::string CWave::WAVE_1_ENEMY_FILE = "data\\FILE\\enemy_000.txt";
const std::string CWave::WAVE_2_ENEMY_FILE = "data\\FILE\\enemy_001.txt";
const std::string CWave::WAVE_3_ENEMY_FILE = "data\\FILE\\enemy_002.txt";
const std::string CWave::WAVE_BOSS_ENEMY_FILE = "data\\FILE\\enemy_003.txt";

const std::string CWave::WAVE_1_BLOCK_FILE = "data\\FILE\\block_000.txt";
const std::string CWave::WAVE_2_BLOCK_FILE = "data\\FILE\\block_001.txt";
const std::string CWave::WAVE_3_BLOCK_FILE = "data\\FILE\\block_002.txt";
const std::string CWave::WAVE_BOSS_BLOCK_FILE = "data\\FILE\\block_003.txt";
//=============================================
//コンストラクタ
//=============================================
CWave::CWave():m_CurrentWave()
{
}

//=============================================
//デストラクタ
//=============================================
CWave::~CWave()
{
}

//=============================================
//初期化
//=============================================
HRESULT CWave::Init()
{
	m_CurrentWave = WAVE::NONE;
	//ウェーブ設定
	SetWave();
	return S_OK;
}

//=============================================
//終了
//=============================================
void CWave::Uninit()
{
}

//=============================================
//更新
//=============================================
void CWave::Update()
{
	if (CEnemy::m_NumEnemy <= 0)
	{
		SetWave();
	}
}

//=============================================
//描画
//=============================================
void CWave::Draw()
{
}

//=============================================
//ウェーブ設定
//=============================================
void CWave::SetWave()
{
	switch (m_CurrentWave)
	{//次のウェーブに切り替える
	case WAVE::NONE:
		m_CurrentWave = WAVE::ONE;
		LoadBlock(&WAVE_1_BLOCK_FILE);
		LoadEnemy(&WAVE_1_ENEMY_FILE);
		break;
	case WAVE::ONE:
		m_CurrentWave = WAVE::TWO;
		LoadBlock(&WAVE_2_BLOCK_FILE);
		LoadEnemy(&WAVE_2_ENEMY_FILE);
		break;
	case WAVE::TWO:
		m_CurrentWave = WAVE::THREE;
		LoadBlock(&WAVE_3_BLOCK_FILE);
		LoadEnemy(&WAVE_3_ENEMY_FILE);
		break;
	case WAVE::THREE:
		m_CurrentWave = WAVE::BOSS;
		LoadBlock(&WAVE_BOSS_BLOCK_FILE);
		LoadEnemy(&WAVE_BOSS_ENEMY_FILE);
		break;
	case WAVE::BOSS:
		CManager::m_pFade->SetFade(CScene::MODE::MODE_RESULT);
		break;
	default:
		break;
	}
}

//=============================================
//現在のウェーブを取得
//=============================================
CWave::WAVE CWave::GetWave()
{
	return m_CurrentWave;
}

//=============================================
//ブロックをロード
//=============================================
void CWave::LoadBlock(const std::string* pFileName)
{
	char aDataSearch[TXT_MAX];
	char aEqual[TXT_MAX]; //[＝]読み込み用
	int nNumBlock; //ブロックの数

	//ファイルの読み込み
	FILE* pFile = fopen(pFileName->c_str(), "r");

	if (pFile == NULL)
	{//種類の情報のデータファイルが開けなかった場合
		//処理を終了する
		return;
	}
	//ENDが見つかるまで読み込みを繰り返す
	while (1)
	{
		fscanf(pFile, "%s", aDataSearch); //検索

		if (!strcmp(aDataSearch, "END"))
		{//読み込みを終了
			fclose(pFile);
			break;
		}
		if (aDataSearch[0] == '#')
		{
			continue;
		}

		if (!strcmp(aDataSearch, "NUM_BLOCK"))
		{//モデル数読み込み
			fscanf(pFile, "%s", &aEqual[0]);
			fscanf(pFile, "%d", &nNumBlock);
		}
		if (!strcmp(aDataSearch, "BLOCKSET"))
		{
			//項目ごとのデータを代入
			while (1)
			{
				fscanf(pFile, "%s", aDataSearch); //検索

				if (!strcmp(aDataSearch, "END_BLOCKSET"))
				{
					//エネミー生成
					CBlock::Create(m_LoadBlock.type, m_LoadBlock.pos, m_LoadBlock.rot, 1, false);
					break;
				}
				else if (!strcmp(aDataSearch, "POS"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%f %f %f",
						&m_LoadBlock.pos.x,
						&m_LoadBlock.pos.y,
						&m_LoadBlock.pos.z);
				}
				else if (!strcmp(aDataSearch, "ROT"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%f %f %f",
						&m_LoadBlock.rot.x,
						&m_LoadBlock.rot.y,
						&m_LoadBlock.rot.z);
				}
				else if (!strcmp(aDataSearch, "TYPE"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%d", &m_LoadBlock.type);
				}
			}
		}
	}
}

//=============================================
//エネミーをロード
//=============================================
void CWave::LoadEnemy(const std::string* pFileName)
{
	char aDataSearch[TXT_MAX];
	char aEqual[TXT_MAX]; //[＝]読み込み用
	int nNumEnemy; //エネミーの数

	//ファイルの読み込み
	FILE* pFile = fopen(pFileName->c_str(), "r");

	if (pFile == NULL)
	{//種類の情報のデータファイルが開けなかった場合
		//処理を終了する
		return;
	}
	//ENDが見つかるまで読み込みを繰り返す
	while (1)
	{
		fscanf(pFile, "%s", aDataSearch); //検索

		if (!strcmp(aDataSearch, "END"))
		{//読み込みを終了
			fclose(pFile);
			break;
		}
		if (aDataSearch[0] == '#')
		{
			continue;
		}

		if (!strcmp(aDataSearch, "NUM_ENEMY"))
		{//モデル数読み込み
			fscanf(pFile, "%s", &aEqual[0]);
			fscanf(pFile, "%d", &nNumEnemy);
		}
		if (!strcmp(aDataSearch, "ENEMYSET"))
		{
			//項目ごとのデータを代入
			while (1)
			{
				fscanf(pFile, "%s", aDataSearch); //検索

				if (!strcmp(aDataSearch, "END_ENEMYSET"))
				{
					//エネミー生成
					CEnemy::Create(m_LoadEnemy.pos, m_LoadEnemy.rot, m_LoadEnemy.type);
					break;
				}
				else if (!strcmp(aDataSearch, "POS"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%f %f %f",
						&m_LoadEnemy.pos.x,
						&m_LoadEnemy.pos.y,
						&m_LoadEnemy.pos.z);
				}
				else if (!strcmp(aDataSearch, "ROT"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%f %f %f",
						&m_LoadEnemy.rot.x,
						&m_LoadEnemy.rot.y,
						&m_LoadEnemy.rot.z);
				}
				else if (!strcmp(aDataSearch, "TYPE"))
				{
					fscanf(pFile, "%s", &aEqual[0]);
					fscanf(pFile, "%d", &m_LoadEnemy.type);
				}
			}
		}
	}
}
